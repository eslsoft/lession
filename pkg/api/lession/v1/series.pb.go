// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: lession/v1/series.proto

package lessionv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// SeriesStatus enumerates lifecycle stages for series.
type SeriesStatus int32

const (
	// SERIES_STATUS_UNSPECIFIED is the default zero value.
	SeriesStatus_SERIES_STATUS_UNSPECIFIED SeriesStatus = 0
	// SERIES_STATUS_DRAFT indicates the series is being prepared.
	SeriesStatus_SERIES_STATUS_DRAFT SeriesStatus = 1
	// SERIES_STATUS_PUBLISHED indicates the series is live to listeners.
	SeriesStatus_SERIES_STATUS_PUBLISHED SeriesStatus = 2
	// SERIES_STATUS_ARCHIVED indicates the series is retired.
	SeriesStatus_SERIES_STATUS_ARCHIVED SeriesStatus = 3
)

// Enum value maps for SeriesStatus.
var (
	SeriesStatus_name = map[int32]string{
		0: "SERIES_STATUS_UNSPECIFIED",
		1: "SERIES_STATUS_DRAFT",
		2: "SERIES_STATUS_PUBLISHED",
		3: "SERIES_STATUS_ARCHIVED",
	}
	SeriesStatus_value = map[string]int32{
		"SERIES_STATUS_UNSPECIFIED": 0,
		"SERIES_STATUS_DRAFT":       1,
		"SERIES_STATUS_PUBLISHED":   2,
		"SERIES_STATUS_ARCHIVED":    3,
	}
)

func (x SeriesStatus) Enum() *SeriesStatus {
	p := new(SeriesStatus)
	*p = x
	return p
}

func (x SeriesStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SeriesStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_lession_v1_series_proto_enumTypes[0].Descriptor()
}

func (SeriesStatus) Type() protoreflect.EnumType {
	return &file_lession_v1_series_proto_enumTypes[0]
}

func (x SeriesStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SeriesStatus.Descriptor instead.
func (SeriesStatus) EnumDescriptor() ([]byte, []int) {
	return file_lession_v1_series_proto_rawDescGZIP(), []int{0}
}

// EpisodeStatus enumerates lifecycle stages for episodes.
type EpisodeStatus int32

const (
	// EPISODE_STATUS_UNSPECIFIED is the default zero value.
	EpisodeStatus_EPISODE_STATUS_UNSPECIFIED EpisodeStatus = 0
	// EPISODE_STATUS_DRAFT indicates the episode is being prepared.
	EpisodeStatus_EPISODE_STATUS_DRAFT EpisodeStatus = 1
	// EPISODE_STATUS_READY indicates the episode is content-complete but pending publish.
	EpisodeStatus_EPISODE_STATUS_READY EpisodeStatus = 2
	// EPISODE_STATUS_PUBLISHED indicates the episode is live to listeners.
	EpisodeStatus_EPISODE_STATUS_PUBLISHED EpisodeStatus = 3
	// EPISODE_STATUS_ARCHIVED indicates the episode is retired.
	EpisodeStatus_EPISODE_STATUS_ARCHIVED EpisodeStatus = 4
)

// Enum value maps for EpisodeStatus.
var (
	EpisodeStatus_name = map[int32]string{
		0: "EPISODE_STATUS_UNSPECIFIED",
		1: "EPISODE_STATUS_DRAFT",
		2: "EPISODE_STATUS_READY",
		3: "EPISODE_STATUS_PUBLISHED",
		4: "EPISODE_STATUS_ARCHIVED",
	}
	EpisodeStatus_value = map[string]int32{
		"EPISODE_STATUS_UNSPECIFIED": 0,
		"EPISODE_STATUS_DRAFT":       1,
		"EPISODE_STATUS_READY":       2,
		"EPISODE_STATUS_PUBLISHED":   3,
		"EPISODE_STATUS_ARCHIVED":    4,
	}
)

func (x EpisodeStatus) Enum() *EpisodeStatus {
	p := new(EpisodeStatus)
	*p = x
	return p
}

func (x EpisodeStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EpisodeStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_lession_v1_series_proto_enumTypes[1].Descriptor()
}

func (EpisodeStatus) Type() protoreflect.EnumType {
	return &file_lession_v1_series_proto_enumTypes[1]
}

func (x EpisodeStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EpisodeStatus.Descriptor instead.
func (EpisodeStatus) EnumDescriptor() ([]byte, []int) {
	return file_lession_v1_series_proto_rawDescGZIP(), []int{1}
}

// MediaType enumerates supported media asset categories.
type MediaType int32

const (
	// MEDIA_TYPE_UNSPECIFIED is the default zero value.
	MediaType_MEDIA_TYPE_UNSPECIFIED MediaType = 0
	// MEDIA_TYPE_VIDEO represents a video asset.
	MediaType_MEDIA_TYPE_VIDEO MediaType = 1
	// MEDIA_TYPE_AUDIO represents an audio-only asset.
	MediaType_MEDIA_TYPE_AUDIO MediaType = 2
)

// Enum value maps for MediaType.
var (
	MediaType_name = map[int32]string{
		0: "MEDIA_TYPE_UNSPECIFIED",
		1: "MEDIA_TYPE_VIDEO",
		2: "MEDIA_TYPE_AUDIO",
	}
	MediaType_value = map[string]int32{
		"MEDIA_TYPE_UNSPECIFIED": 0,
		"MEDIA_TYPE_VIDEO":       1,
		"MEDIA_TYPE_AUDIO":       2,
	}
)

func (x MediaType) Enum() *MediaType {
	p := new(MediaType)
	*p = x
	return p
}

func (x MediaType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MediaType) Descriptor() protoreflect.EnumDescriptor {
	return file_lession_v1_series_proto_enumTypes[2].Descriptor()
}

func (MediaType) Type() protoreflect.EnumType {
	return &file_lession_v1_series_proto_enumTypes[2]
}

func (x MediaType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MediaType.Descriptor instead.
func (MediaType) EnumDescriptor() ([]byte, []int) {
	return file_lession_v1_series_proto_rawDescGZIP(), []int{2}
}

// TranscriptFormat enumerates supported transcript formats.
type TranscriptFormat int32

const (
	// TRANSCRIPT_FORMAT_UNSPECIFIED is the default zero value.
	TranscriptFormat_TRANSCRIPT_FORMAT_UNSPECIFIED TranscriptFormat = 0
	// TRANSCRIPT_FORMAT_PLAIN represents UTF-8 plain text.
	TranscriptFormat_TRANSCRIPT_FORMAT_PLAIN TranscriptFormat = 1
	// TRANSCRIPT_FORMAT_MARKDOWN represents Markdown content.
	TranscriptFormat_TRANSCRIPT_FORMAT_MARKDOWN TranscriptFormat = 2
	// TRANSCRIPT_FORMAT_SRT represents SubRip text.
	TranscriptFormat_TRANSCRIPT_FORMAT_SRT TranscriptFormat = 3
	// TRANSCRIPT_FORMAT_JSON represents JSON formatted content.
	TranscriptFormat_TRANSCRIPT_FORMAT_JSON TranscriptFormat = 4
)

// Enum value maps for TranscriptFormat.
var (
	TranscriptFormat_name = map[int32]string{
		0: "TRANSCRIPT_FORMAT_UNSPECIFIED",
		1: "TRANSCRIPT_FORMAT_PLAIN",
		2: "TRANSCRIPT_FORMAT_MARKDOWN",
		3: "TRANSCRIPT_FORMAT_SRT",
		4: "TRANSCRIPT_FORMAT_JSON",
	}
	TranscriptFormat_value = map[string]int32{
		"TRANSCRIPT_FORMAT_UNSPECIFIED": 0,
		"TRANSCRIPT_FORMAT_PLAIN":       1,
		"TRANSCRIPT_FORMAT_MARKDOWN":    2,
		"TRANSCRIPT_FORMAT_SRT":         3,
		"TRANSCRIPT_FORMAT_JSON":        4,
	}
)

func (x TranscriptFormat) Enum() *TranscriptFormat {
	p := new(TranscriptFormat)
	*p = x
	return p
}

func (x TranscriptFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TranscriptFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_lession_v1_series_proto_enumTypes[3].Descriptor()
}

func (TranscriptFormat) Type() protoreflect.EnumType {
	return &file_lession_v1_series_proto_enumTypes[3]
}

func (x TranscriptFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TranscriptFormat.Descriptor instead.
func (TranscriptFormat) EnumDescriptor() ([]byte, []int) {
	return file_lession_v1_series_proto_rawDescGZIP(), []int{3}
}

// Series describes a media series with optional embedded episodes.
type Series struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the server-assigned identifier for the series.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// slug is a human-readable, unique identifier used in URLs.
	Slug string `protobuf:"bytes,2,opt,name=slug,proto3" json:"slug,omitempty"`
	// title is the series headline shown to listeners.
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	// summary provides a short synopsis of the series.
	Summary string `protobuf:"bytes,4,opt,name=summary,proto3" json:"summary,omitempty"`
	// language declares the primary locale of the series content (ISO 639-1).
	Language string `protobuf:"bytes,5,opt,name=language,proto3" json:"language,omitempty"`
	// level indicates the difficulty level (e.g. beginner, intermediate).
	Level string `protobuf:"bytes,6,opt,name=level,proto3" json:"level,omitempty"`
	// tags captures optional classification keywords.
	Tags []string `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty"`
	// cover_url references artwork that represents the series.
	CoverUrl string `protobuf:"bytes,8,opt,name=cover_url,json=coverUrl,proto3" json:"cover_url,omitempty"`
	// status tracks the lifecycle stage of the series.
	Status SeriesStatus `protobuf:"varint,9,opt,name=status,proto3,enum=lession.v1.SeriesStatus" json:"status,omitempty"`
	// episode_count is a cached number of episodes in the series.
	EpisodeCount uint32 `protobuf:"varint,10,opt,name=episode_count,json=episodeCount,proto3" json:"episode_count,omitempty"`
	// created_at records when the series was created.
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// updated_at records when the series was last modified.
	UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	// published_at records when the series was first published, if applicable.
	PublishedAt *timestamppb.Timestamp `protobuf:"bytes,13,opt,name=published_at,json=publishedAt,proto3" json:"published_at,omitempty"`
	// author_ids references the creators responsible for the series.
	AuthorIds []string `protobuf:"bytes,14,rep,name=author_ids,json=authorIds,proto3" json:"author_ids,omitempty"`
	// episodes optionally contains the ordered episodes of the series.
	Episodes      []*Episode `protobuf:"bytes,20,rep,name=episodes,proto3" json:"episodes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Series) Reset() {
	*x = Series{}
	mi := &file_lession_v1_series_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Series) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Series) ProtoMessage() {}

func (x *Series) ProtoReflect() protoreflect.Message {
	mi := &file_lession_v1_series_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Series.ProtoReflect.Descriptor instead.
func (*Series) Descriptor() ([]byte, []int) {
	return file_lession_v1_series_proto_rawDescGZIP(), []int{0}
}

func (x *Series) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Series) GetSlug() string {
	if x != nil {
		return x.Slug
	}
	return ""
}

func (x *Series) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *Series) GetSummary() string {
	if x != nil {
		return x.Summary
	}
	return ""
}

func (x *Series) GetLanguage() string {
	if x != nil {
		return x.Language
	}
	return ""
}

func (x *Series) GetLevel() string {
	if x != nil {
		return x.Level
	}
	return ""
}

func (x *Series) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *Series) GetCoverUrl() string {
	if x != nil {
		return x.CoverUrl
	}
	return ""
}

func (x *Series) GetStatus() SeriesStatus {
	if x != nil {
		return x.Status
	}
	return SeriesStatus_SERIES_STATUS_UNSPECIFIED
}

func (x *Series) GetEpisodeCount() uint32 {
	if x != nil {
		return x.EpisodeCount
	}
	return 0
}

func (x *Series) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *Series) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

func (x *Series) GetPublishedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.PublishedAt
	}
	return nil
}

func (x *Series) GetAuthorIds() []string {
	if x != nil {
		return x.AuthorIds
	}
	return nil
}

func (x *Series) GetEpisodes() []*Episode {
	if x != nil {
		return x.Episodes
	}
	return nil
}

// Episode captures content units within a series.
type Episode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the server-assigned identifier for the episode.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// series_id is the identifier of the parent series.
	SeriesId string `protobuf:"bytes,2,opt,name=series_id,json=seriesId,proto3" json:"series_id,omitempty"`
	// seq is the display order of the episode inside the series.
	Seq uint32 `protobuf:"varint,3,opt,name=seq,proto3" json:"seq,omitempty"`
	// title is the episode headline shown to listeners.
	Title string `protobuf:"bytes,4,opt,name=title,proto3" json:"title,omitempty"`
	// description provides additional context for the episode.
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// duration tracks the expected consumption time for the episode.
	Duration *durationpb.Duration `protobuf:"bytes,6,opt,name=duration,proto3" json:"duration,omitempty"`
	// status tracks the lifecycle stage of the episode.
	Status EpisodeStatus `protobuf:"varint,7,opt,name=status,proto3,enum=lession.v1.EpisodeStatus" json:"status,omitempty"`
	// resource describes the associated audio or video asset.
	Resource *MediaResource `protobuf:"bytes,8,opt,name=resource,proto3" json:"resource,omitempty"`
	// transcript stores the textual version of the episode content.
	Transcript *Transcript `protobuf:"bytes,9,opt,name=transcript,proto3" json:"transcript,omitempty"`
	// created_at records when the episode was created.
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// updated_at records when the episode was last modified.
	UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,11,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	// published_at records when the episode was first published, if applicable.
	PublishedAt   *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=published_at,json=publishedAt,proto3" json:"published_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Episode) Reset() {
	*x = Episode{}
	mi := &file_lession_v1_series_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Episode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Episode) ProtoMessage() {}

func (x *Episode) ProtoReflect() protoreflect.Message {
	mi := &file_lession_v1_series_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Episode.ProtoReflect.Descriptor instead.
func (*Episode) Descriptor() ([]byte, []int) {
	return file_lession_v1_series_proto_rawDescGZIP(), []int{1}
}

func (x *Episode) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Episode) GetSeriesId() string {
	if x != nil {
		return x.SeriesId
	}
	return ""
}

func (x *Episode) GetSeq() uint32 {
	if x != nil {
		return x.Seq
	}
	return 0
}

func (x *Episode) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *Episode) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Episode) GetDuration() *durationpb.Duration {
	if x != nil {
		return x.Duration
	}
	return nil
}

func (x *Episode) GetStatus() EpisodeStatus {
	if x != nil {
		return x.Status
	}
	return EpisodeStatus_EPISODE_STATUS_UNSPECIFIED
}

func (x *Episode) GetResource() *MediaResource {
	if x != nil {
		return x.Resource
	}
	return nil
}

func (x *Episode) GetTranscript() *Transcript {
	if x != nil {
		return x.Transcript
	}
	return nil
}

func (x *Episode) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *Episode) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

func (x *Episode) GetPublishedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.PublishedAt
	}
	return nil
}

// MediaResource binds an uploaded asset to an episode and exposes playback metadata.
type MediaResource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// asset_id is the server-assigned identifier for the persisted asset.
	AssetId string `protobuf:"bytes,1,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// type classifies the media asset.
	Type MediaType `protobuf:"varint,2,opt,name=type,proto3,enum=lession.v1.MediaType" json:"type,omitempty"`
	// playback_url is populated by the system when the public stream is ready.
	PlaybackUrl string `protobuf:"bytes,3,opt,name=playback_url,json=playbackUrl,proto3" json:"playback_url,omitempty"`
	// mime_type conveys the content type for the asset.
	MimeType      string `protobuf:"bytes,4,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MediaResource) Reset() {
	*x = MediaResource{}
	mi := &file_lession_v1_series_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MediaResource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MediaResource) ProtoMessage() {}

func (x *MediaResource) ProtoReflect() protoreflect.Message {
	mi := &file_lession_v1_series_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MediaResource.ProtoReflect.Descriptor instead.
func (*MediaResource) Descriptor() ([]byte, []int) {
	return file_lession_v1_series_proto_rawDescGZIP(), []int{2}
}

func (x *MediaResource) GetAssetId() string {
	if x != nil {
		return x.AssetId
	}
	return ""
}

func (x *MediaResource) GetType() MediaType {
	if x != nil {
		return x.Type
	}
	return MediaType_MEDIA_TYPE_UNSPECIFIED
}

func (x *MediaResource) GetPlaybackUrl() string {
	if x != nil {
		return x.PlaybackUrl
	}
	return ""
}

func (x *MediaResource) GetMimeType() string {
	if x != nil {
		return x.MimeType
	}
	return ""
}

// Transcript represents the textual script of an episode.
type Transcript struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// language declares the locale of the transcript (ISO 639-1).
	Language string `protobuf:"bytes,1,opt,name=language,proto3" json:"language,omitempty"`
	// format specifies the data shape for the transcript content.
	Format TranscriptFormat `protobuf:"varint,2,opt,name=format,proto3,enum=lession.v1.TranscriptFormat" json:"format,omitempty"`
	// content stores the transcript payload, encoded per format.
	Content       string `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transcript) Reset() {
	*x = Transcript{}
	mi := &file_lession_v1_series_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transcript) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transcript) ProtoMessage() {}

func (x *Transcript) ProtoReflect() protoreflect.Message {
	mi := &file_lession_v1_series_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transcript.ProtoReflect.Descriptor instead.
func (*Transcript) Descriptor() ([]byte, []int) {
	return file_lession_v1_series_proto_rawDescGZIP(), []int{3}
}

func (x *Transcript) GetLanguage() string {
	if x != nil {
		return x.Language
	}
	return ""
}

func (x *Transcript) GetFormat() TranscriptFormat {
	if x != nil {
		return x.Format
	}
	return TranscriptFormat_TRANSCRIPT_FORMAT_UNSPECIFIED
}

func (x *Transcript) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

// SeriesDraft captures modifiable fields for creating or updating a series.
type SeriesDraft struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// slug is a human-readable, unique identifier used in URLs.
	Slug string `protobuf:"bytes,1,opt,name=slug,proto3" json:"slug,omitempty"`
	// title is the series headline shown to listeners.
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// summary provides a short synopsis of the series.
	Summary string `protobuf:"bytes,3,opt,name=summary,proto3" json:"summary,omitempty"`
	// language declares the primary locale of the series content (ISO 639-1).
	Language string `protobuf:"bytes,4,opt,name=language,proto3" json:"language,omitempty"`
	// level indicates the difficulty level (e.g. beginner, intermediate).
	Level string `protobuf:"bytes,5,opt,name=level,proto3" json:"level,omitempty"`
	// tags captures optional classification keywords.
	Tags []string `protobuf:"bytes,6,rep,name=tags,proto3" json:"tags,omitempty"`
	// cover_url references artwork that represents the series.
	CoverUrl string `protobuf:"bytes,7,opt,name=cover_url,json=coverUrl,proto3" json:"cover_url,omitempty"`
	// status tracks the lifecycle stage of the series.
	Status SeriesStatus `protobuf:"varint,8,opt,name=status,proto3,enum=lession.v1.SeriesStatus" json:"status,omitempty"`
	// author_ids references the creators responsible for the series.
	AuthorIds []string `protobuf:"bytes,9,rep,name=author_ids,json=authorIds,proto3" json:"author_ids,omitempty"`
	// episodes provides initial or replacement episodes for the series.
	Episodes      []*EpisodeDraft `protobuf:"bytes,20,rep,name=episodes,proto3" json:"episodes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SeriesDraft) Reset() {
	*x = SeriesDraft{}
	mi := &file_lession_v1_series_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SeriesDraft) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SeriesDraft) ProtoMessage() {}

func (x *SeriesDraft) ProtoReflect() protoreflect.Message {
	mi := &file_lession_v1_series_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SeriesDraft.ProtoReflect.Descriptor instead.
func (*SeriesDraft) Descriptor() ([]byte, []int) {
	return file_lession_v1_series_proto_rawDescGZIP(), []int{4}
}

func (x *SeriesDraft) GetSlug() string {
	if x != nil {
		return x.Slug
	}
	return ""
}

func (x *SeriesDraft) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *SeriesDraft) GetSummary() string {
	if x != nil {
		return x.Summary
	}
	return ""
}

func (x *SeriesDraft) GetLanguage() string {
	if x != nil {
		return x.Language
	}
	return ""
}

func (x *SeriesDraft) GetLevel() string {
	if x != nil {
		return x.Level
	}
	return ""
}

func (x *SeriesDraft) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *SeriesDraft) GetCoverUrl() string {
	if x != nil {
		return x.CoverUrl
	}
	return ""
}

func (x *SeriesDraft) GetStatus() SeriesStatus {
	if x != nil {
		return x.Status
	}
	return SeriesStatus_SERIES_STATUS_UNSPECIFIED
}

func (x *SeriesDraft) GetAuthorIds() []string {
	if x != nil {
		return x.AuthorIds
	}
	return nil
}

func (x *SeriesDraft) GetEpisodes() []*EpisodeDraft {
	if x != nil {
		return x.Episodes
	}
	return nil
}

// EpisodeDraft captures modifiable fields for creating or updating an episode.
type EpisodeDraft struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// seq is the display order of the episode inside the series.
	Seq uint32 `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	// title is the episode headline shown to listeners.
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// description provides additional context for the episode.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// duration tracks the expected consumption time for the episode.
	Duration *durationpb.Duration `protobuf:"bytes,4,opt,name=duration,proto3" json:"duration,omitempty"`
	// status tracks the lifecycle stage of the episode.
	Status EpisodeStatus `protobuf:"varint,5,opt,name=status,proto3,enum=lession.v1.EpisodeStatus" json:"status,omitempty"`
	// resource describes the associated audio or video asset. When creating, populate
	// resource.asset_id with an existing asset; server-managed fields (playback_url, mime_type)
	// are ignored.
	Resource *MediaResource `protobuf:"bytes,6,opt,name=resource,proto3" json:"resource,omitempty"`
	// transcript stores the textual version of the episode content.
	Transcript    *Transcript `protobuf:"bytes,7,opt,name=transcript,proto3" json:"transcript,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EpisodeDraft) Reset() {
	*x = EpisodeDraft{}
	mi := &file_lession_v1_series_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EpisodeDraft) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EpisodeDraft) ProtoMessage() {}

func (x *EpisodeDraft) ProtoReflect() protoreflect.Message {
	mi := &file_lession_v1_series_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EpisodeDraft.ProtoReflect.Descriptor instead.
func (*EpisodeDraft) Descriptor() ([]byte, []int) {
	return file_lession_v1_series_proto_rawDescGZIP(), []int{5}
}

func (x *EpisodeDraft) GetSeq() uint32 {
	if x != nil {
		return x.Seq
	}
	return 0
}

func (x *EpisodeDraft) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *EpisodeDraft) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *EpisodeDraft) GetDuration() *durationpb.Duration {
	if x != nil {
		return x.Duration
	}
	return nil
}

func (x *EpisodeDraft) GetStatus() EpisodeStatus {
	if x != nil {
		return x.Status
	}
	return EpisodeStatus_EPISODE_STATUS_UNSPECIFIED
}

func (x *EpisodeDraft) GetResource() *MediaResource {
	if x != nil {
		return x.Resource
	}
	return nil
}

func (x *EpisodeDraft) GetTranscript() *Transcript {
	if x != nil {
		return x.Transcript
	}
	return nil
}

var File_lession_v1_series_proto protoreflect.FileDescriptor

const file_lession_v1_series_proto_rawDesc = "" +
	"\n" +
	"\x17lession/v1/series.proto\x12\n" +
	"lession.v1\x1a\x1egoogle/protobuf/duration.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\x9b\x04\n" +
	"\x06Series\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04slug\x18\x02 \x01(\tR\x04slug\x12\x14\n" +
	"\x05title\x18\x03 \x01(\tR\x05title\x12\x18\n" +
	"\asummary\x18\x04 \x01(\tR\asummary\x12\x1a\n" +
	"\blanguage\x18\x05 \x01(\tR\blanguage\x12\x14\n" +
	"\x05level\x18\x06 \x01(\tR\x05level\x12\x12\n" +
	"\x04tags\x18\a \x03(\tR\x04tags\x12\x1b\n" +
	"\tcover_url\x18\b \x01(\tR\bcoverUrl\x120\n" +
	"\x06status\x18\t \x01(\x0e2\x18.lession.v1.SeriesStatusR\x06status\x12#\n" +
	"\repisode_count\x18\n" +
	" \x01(\rR\fepisodeCount\x129\n" +
	"\n" +
	"created_at\x18\v \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
	"\n" +
	"updated_at\x18\f \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x12=\n" +
	"\fpublished_at\x18\r \x01(\v2\x1a.google.protobuf.TimestampR\vpublishedAt\x12\x1d\n" +
	"\n" +
	"author_ids\x18\x0e \x03(\tR\tauthorIds\x12/\n" +
	"\bepisodes\x18\x14 \x03(\v2\x13.lession.v1.EpisodeR\bepisodes\"\x8e\x04\n" +
	"\aEpisode\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1b\n" +
	"\tseries_id\x18\x02 \x01(\tR\bseriesId\x12\x10\n" +
	"\x03seq\x18\x03 \x01(\rR\x03seq\x12\x14\n" +
	"\x05title\x18\x04 \x01(\tR\x05title\x12 \n" +
	"\vdescription\x18\x05 \x01(\tR\vdescription\x125\n" +
	"\bduration\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\bduration\x121\n" +
	"\x06status\x18\a \x01(\x0e2\x19.lession.v1.EpisodeStatusR\x06status\x125\n" +
	"\bresource\x18\b \x01(\v2\x19.lession.v1.MediaResourceR\bresource\x126\n" +
	"\n" +
	"transcript\x18\t \x01(\v2\x16.lession.v1.TranscriptR\n" +
	"transcript\x129\n" +
	"\n" +
	"created_at\x18\n" +
	" \x01(\v2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n" +
	"\n" +
	"updated_at\x18\v \x01(\v2\x1a.google.protobuf.TimestampR\tupdatedAt\x12=\n" +
	"\fpublished_at\x18\f \x01(\v2\x1a.google.protobuf.TimestampR\vpublishedAt\"\x95\x01\n" +
	"\rMediaResource\x12\x19\n" +
	"\basset_id\x18\x01 \x01(\tR\aassetId\x12)\n" +
	"\x04type\x18\x02 \x01(\x0e2\x15.lession.v1.MediaTypeR\x04type\x12!\n" +
	"\fplayback_url\x18\x03 \x01(\tR\vplaybackUrl\x12\x1b\n" +
	"\tmime_type\x18\x04 \x01(\tR\bmimeType\"x\n" +
	"\n" +
	"Transcript\x12\x1a\n" +
	"\blanguage\x18\x01 \x01(\tR\blanguage\x124\n" +
	"\x06format\x18\x02 \x01(\x0e2\x1c.lession.v1.TranscriptFormatR\x06format\x12\x18\n" +
	"\acontent\x18\x03 \x01(\tR\acontent\"\xbb\x02\n" +
	"\vSeriesDraft\x12\x12\n" +
	"\x04slug\x18\x01 \x01(\tR\x04slug\x12\x14\n" +
	"\x05title\x18\x02 \x01(\tR\x05title\x12\x18\n" +
	"\asummary\x18\x03 \x01(\tR\asummary\x12\x1a\n" +
	"\blanguage\x18\x04 \x01(\tR\blanguage\x12\x14\n" +
	"\x05level\x18\x05 \x01(\tR\x05level\x12\x12\n" +
	"\x04tags\x18\x06 \x03(\tR\x04tags\x12\x1b\n" +
	"\tcover_url\x18\a \x01(\tR\bcoverUrl\x120\n" +
	"\x06status\x18\b \x01(\x0e2\x18.lession.v1.SeriesStatusR\x06status\x12\x1d\n" +
	"\n" +
	"author_ids\x18\t \x03(\tR\tauthorIds\x124\n" +
	"\bepisodes\x18\x14 \x03(\v2\x18.lession.v1.EpisodeDraftR\bepisodes\"\xb1\x02\n" +
	"\fEpisodeDraft\x12\x10\n" +
	"\x03seq\x18\x01 \x01(\rR\x03seq\x12\x14\n" +
	"\x05title\x18\x02 \x01(\tR\x05title\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x125\n" +
	"\bduration\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\bduration\x121\n" +
	"\x06status\x18\x05 \x01(\x0e2\x19.lession.v1.EpisodeStatusR\x06status\x125\n" +
	"\bresource\x18\x06 \x01(\v2\x19.lession.v1.MediaResourceR\bresource\x126\n" +
	"\n" +
	"transcript\x18\a \x01(\v2\x16.lession.v1.TranscriptR\n" +
	"transcript*\x7f\n" +
	"\fSeriesStatus\x12\x1d\n" +
	"\x19SERIES_STATUS_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13SERIES_STATUS_DRAFT\x10\x01\x12\x1b\n" +
	"\x17SERIES_STATUS_PUBLISHED\x10\x02\x12\x1a\n" +
	"\x16SERIES_STATUS_ARCHIVED\x10\x03*\x9e\x01\n" +
	"\rEpisodeStatus\x12\x1e\n" +
	"\x1aEPISODE_STATUS_UNSPECIFIED\x10\x00\x12\x18\n" +
	"\x14EPISODE_STATUS_DRAFT\x10\x01\x12\x18\n" +
	"\x14EPISODE_STATUS_READY\x10\x02\x12\x1c\n" +
	"\x18EPISODE_STATUS_PUBLISHED\x10\x03\x12\x1b\n" +
	"\x17EPISODE_STATUS_ARCHIVED\x10\x04*S\n" +
	"\tMediaType\x12\x1a\n" +
	"\x16MEDIA_TYPE_UNSPECIFIED\x10\x00\x12\x14\n" +
	"\x10MEDIA_TYPE_VIDEO\x10\x01\x12\x14\n" +
	"\x10MEDIA_TYPE_AUDIO\x10\x02*\xa9\x01\n" +
	"\x10TranscriptFormat\x12!\n" +
	"\x1dTRANSCRIPT_FORMAT_UNSPECIFIED\x10\x00\x12\x1b\n" +
	"\x17TRANSCRIPT_FORMAT_PLAIN\x10\x01\x12\x1e\n" +
	"\x1aTRANSCRIPT_FORMAT_MARKDOWN\x10\x02\x12\x19\n" +
	"\x15TRANSCRIPT_FORMAT_SRT\x10\x03\x12\x1a\n" +
	"\x16TRANSCRIPT_FORMAT_JSON\x10\x04B9Z7github.com/eslsoft/lession/pkg/api/lession/v1;lessionv1b\x06proto3"

var (
	file_lession_v1_series_proto_rawDescOnce sync.Once
	file_lession_v1_series_proto_rawDescData []byte
)

func file_lession_v1_series_proto_rawDescGZIP() []byte {
	file_lession_v1_series_proto_rawDescOnce.Do(func() {
		file_lession_v1_series_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_lession_v1_series_proto_rawDesc), len(file_lession_v1_series_proto_rawDesc)))
	})
	return file_lession_v1_series_proto_rawDescData
}

var file_lession_v1_series_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_lession_v1_series_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_lession_v1_series_proto_goTypes = []any{
	(SeriesStatus)(0),             // 0: lession.v1.SeriesStatus
	(EpisodeStatus)(0),            // 1: lession.v1.EpisodeStatus
	(MediaType)(0),                // 2: lession.v1.MediaType
	(TranscriptFormat)(0),         // 3: lession.v1.TranscriptFormat
	(*Series)(nil),                // 4: lession.v1.Series
	(*Episode)(nil),               // 5: lession.v1.Episode
	(*MediaResource)(nil),         // 6: lession.v1.MediaResource
	(*Transcript)(nil),            // 7: lession.v1.Transcript
	(*SeriesDraft)(nil),           // 8: lession.v1.SeriesDraft
	(*EpisodeDraft)(nil),          // 9: lession.v1.EpisodeDraft
	(*timestamppb.Timestamp)(nil), // 10: google.protobuf.Timestamp
	(*durationpb.Duration)(nil),   // 11: google.protobuf.Duration
}
var file_lession_v1_series_proto_depIdxs = []int32{
	0,  // 0: lession.v1.Series.status:type_name -> lession.v1.SeriesStatus
	10, // 1: lession.v1.Series.created_at:type_name -> google.protobuf.Timestamp
	10, // 2: lession.v1.Series.updated_at:type_name -> google.protobuf.Timestamp
	10, // 3: lession.v1.Series.published_at:type_name -> google.protobuf.Timestamp
	5,  // 4: lession.v1.Series.episodes:type_name -> lession.v1.Episode
	11, // 5: lession.v1.Episode.duration:type_name -> google.protobuf.Duration
	1,  // 6: lession.v1.Episode.status:type_name -> lession.v1.EpisodeStatus
	6,  // 7: lession.v1.Episode.resource:type_name -> lession.v1.MediaResource
	7,  // 8: lession.v1.Episode.transcript:type_name -> lession.v1.Transcript
	10, // 9: lession.v1.Episode.created_at:type_name -> google.protobuf.Timestamp
	10, // 10: lession.v1.Episode.updated_at:type_name -> google.protobuf.Timestamp
	10, // 11: lession.v1.Episode.published_at:type_name -> google.protobuf.Timestamp
	2,  // 12: lession.v1.MediaResource.type:type_name -> lession.v1.MediaType
	3,  // 13: lession.v1.Transcript.format:type_name -> lession.v1.TranscriptFormat
	0,  // 14: lession.v1.SeriesDraft.status:type_name -> lession.v1.SeriesStatus
	9,  // 15: lession.v1.SeriesDraft.episodes:type_name -> lession.v1.EpisodeDraft
	11, // 16: lession.v1.EpisodeDraft.duration:type_name -> google.protobuf.Duration
	1,  // 17: lession.v1.EpisodeDraft.status:type_name -> lession.v1.EpisodeStatus
	6,  // 18: lession.v1.EpisodeDraft.resource:type_name -> lession.v1.MediaResource
	7,  // 19: lession.v1.EpisodeDraft.transcript:type_name -> lession.v1.Transcript
	20, // [20:20] is the sub-list for method output_type
	20, // [20:20] is the sub-list for method input_type
	20, // [20:20] is the sub-list for extension type_name
	20, // [20:20] is the sub-list for extension extendee
	0,  // [0:20] is the sub-list for field type_name
}

func init() { file_lession_v1_series_proto_init() }
func file_lession_v1_series_proto_init() {
	if File_lession_v1_series_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_lession_v1_series_proto_rawDesc), len(file_lession_v1_series_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_lession_v1_series_proto_goTypes,
		DependencyIndexes: file_lession_v1_series_proto_depIdxs,
		EnumInfos:         file_lession_v1_series_proto_enumTypes,
		MessageInfos:      file_lession_v1_series_proto_msgTypes,
	}.Build()
	File_lession_v1_series_proto = out.File
	file_lession_v1_series_proto_goTypes = nil
	file_lession_v1_series_proto_depIdxs = nil
}
